import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:equatable/equatable.dart';
import '../services/tor_service.dart';
import '../services/storage_service.dart';
import '../models/models.dart';

// Events
abstract class TorEvent extends Equatable {
  const TorEvent();

  @override
  List<Object?> get props => [];
}

class TorInitialize extends TorEvent {}

class TorConnect extends TorEvent {}

class TorDisconnect extends TorEvent {}

class TorStatusChanged extends TorEvent {
  final TorConnectionStatus status;

  const TorStatusChanged(this.status);

  @override
  List<Object?> get props => [status];
}

class TorBootstrapProgress extends TorEvent {
  final int progress;

  const TorBootstrapProgress(this.progress);

  @override
  List<Object?> get props => [progress];
}

// State
class TorState extends Equatable {
  final TorConnectionStatus status;
  final int bootstrapProgress;
  final String? onionAddress;
  final String? errorMessage;

  const TorState({
    this.status = TorConnectionStatus.disconnected,
    this.bootstrapProgress = 0,
    this.onionAddress,
    this.errorMessage,
  });

  TorState copyWith({
    TorConnectionStatus? status,
    int? bootstrapProgress,
    String? onionAddress,
    String? errorMessage,
  }) {
    return TorState(
      status: status ?? this.status,
      bootstrapProgress: bootstrapProgress ?? this.bootstrapProgress,
      onionAddress: onionAddress ?? this.onionAddress,
      errorMessage: errorMessage,
    );
  }

  @override
  List<Object?> get props => [status, bootstrapProgress, onionAddress, errorMessage];
}

// BLoC
class TorBloc extends Bloc<TorEvent, TorState> {
  final TorService torService;
  final StorageService storageService;

  TorBloc({
    required this.torService,
    required this.storageService,
  }) : super(const TorState()) {
    on<TorInitialize>(_onInitialize);
    on<TorConnect>(_onConnect);
    on<TorDisconnect>(_onDisconnect);
    on<TorStatusChanged>(_onStatusChanged);
    on<TorBootstrapProgress>(_onBootstrapProgress);

    // Listen to tor service streams
    torService.statusStream.listen((status) {
      add(TorStatusChanged(status));
    });

    torService.progressStream.listen((progress) {
      add(TorBootstrapProgress(progress));
    });

    torService.addressStream.listen((address) {
      if (address != null) {
        // Save identity when address is generated
        _saveIdentity(address);
      }
    });
  }

  Future<void> _onInitialize(TorInitialize event, Emitter<TorState> emit) async {
    emit(state.copyWith(status: TorConnectionStatus.connecting));

    try {
      // Check for existing identity
      final existingIdentity = await storageService.loadIdentity();

      if (existingIdentity != null) {
        // Use existing identity
        emit(state.copyWith(onionAddress: existingIdentity.onionAddress));
      }

      // Initialize Tor
      await torService.initialize();

    } catch (e) {
      emit(state.copyWith(
        status: TorConnectionStatus.error,
        errorMessage: e.toString(),
      ));
    }
  }

  Future<void> _onConnect(TorConnect event, Emitter<TorState> emit) async {
    emit(state.copyWith(status: TorConnectionStatus.connecting));

    try {
      await torService.initialize();
    } catch (e) {
      emit(state.copyWith(
        status: TorConnectionStatus.error,
        errorMessage: e.toString(),
      ));
    }
  }

  Future<void> _onDisconnect(TorDisconnect event, Emitter<TorState> emit) async {
    await torService.disconnect();
    emit(state.copyWith(
      status: TorConnectionStatus.disconnected,
      onionAddress: null,
    ));
  }

  void _onStatusChanged(TorStatusChanged event, Emitter<TorState> emit) {
    emit(state.copyWith(status: event.status));
  }

  void _onBootstrapProgress(TorBootstrapProgress event, Emitter<TorState> emit) {
    emit(state.copyWith(bootstrapProgress: event.progress));
  }

  Future<void> _saveIdentity(String address) async {
    final identity = Identity(
      onionAddress: address,
      publicKey: '', // Would be generated by Rust core
      createdAt: DateTime.now(),
    );
    await storageService.saveIdentity(identity);
  }
}
